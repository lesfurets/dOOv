package ${package.name};

import java.util.Spliterator;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Collector;
import java.util.stream.Stream;

import javax.annotation.Generated;

import io.doov.core.FieldId;
import io.doov.core.FieldInfo;
import io.doov.core.FieldModel;
import io.doov.core.FieldModels;
import io.doov.core.dsl.DslId;
import ${target.field.info.package.name}.${target.field.info.class.name};
import ${target.field.info.package.name}.${process.class.name};

@Generated(value = "${source.generator.name}", comments="generated from ${process.class}")
public final class ${target.class.name} implements FieldModel<${process.class.name}> {

    private final List<FieldInfo<${process.class.name}>> fieldInfos;
    private final ${target.model.class.name} model;
    
    public static Collector<Entry<${process.class.name}, Object>, ?, ${target.class.name}> toFieldModel() {
        return FieldModels.toFieldModel(new ${target.class.name}());
    }
    
    public static Collector<Entry<${process.class.name}, Object>, ?, ${target.class.name}> toConcurrentFieldModel() {
        return FieldModels.toConcurrentFieldModel(new ${target.class.name}());
    }

    public ${target.class.name}() {
        this(new ${target.model.class.name}());
    }

    public ${target.class.name}(${target.model.class.name} model) {
        this.fieldInfos = ${target.field.info.class.name}.values();
        this.model = model;
    }

    public ${target.model.class.name} getModel() {
        return model;
    }

    @Override
    public List<FieldInfo<${process.class.name}>> getFieldInfos() {
        return fieldInfos;
    }
    
    @Override
    public Iterator<Map.Entry<${process.class.name}, Object>> iterator() {
        return new Iterator<Map.Entry<${process.class.name}, Object>>() {
            int position = 0;

            @Override
            public boolean hasNext() {
                return position < fieldInfos.size();
            }

            @Override
            public Entry<${process.class.name}, Object> next() {
                try {
                    return ${target.model.class.name}Property.values()[position].toEntry(model);
                } finally {
                    position++;
                }
            }
        };
    }

    @Override
    public Spliterator<Entry<${process.class.name}, Object>> spliterator() {
        final Entry<${process.class.name}, Object>[] entries = ${target.model.class.name}Property.entries(model);
        return Arrays.spliterator(entries, 0, entries.length);
    }

    @Override
    public Stream<Entry<${process.class.name}, Object>> stream() {
        return Arrays.stream(${target.model.class.name}Property.values()).map(p -> p.toEntry(model));
    }

    @Override
    public Stream<Entry<${process.class.name}, Object>> parallelStream() {
        return Arrays.stream(${target.model.class.name}Property.values()).parallel().map(p -> p.toEntry(model));
    }

    @Override
    public <T> T get(${process.class.name} fieldId) {
${map.getter.if}        return null;
    }

${map.getter}

    @Override
    public <T> void set(${process.class.name} fieldId, T value) {
${map.setter.if}    }

${map.setter}

    @SuppressWarnings("unchecked")
    private static enum ${target.model.class.name}Property {
${map.properties}
        ;

        private final ${process.class.name} fieldId;

        ${target.model.class.name}Property(${process.class.name} fieldId) {
            this.fieldId = fieldId;
        }
        
        Map.Entry<${process.class.name}, Object> toEntry(${target.model.class.name} model) {
            return new SupplierEntry<>(fieldId, model, supplier());
        }

        public abstract <T> BiConsumer<${target.model.class.name}, T> consumer();

        public abstract <T> Function<${target.model.class.name}, T> supplier();

        public static Map.Entry<${process.class.name}, Object>[] entries(${target.model.class.name} model){
            ${target.model.class.name}Property[] values = ${target.model.class.name}Property.values();
            Map.Entry<${process.class.name}, Object>[] entries = new Map.Entry[values.length];
            for(int i=0; i< values.length;i++) {
                entries[i] = values[i].toEntry(model);
            }
            return entries;
        }
    }

    private static class SupplierEntry<M, T> implements Map.Entry<${process.class.name}, Object> {
        final ${process.class.name} fieldId;
        final M model;
        final Function<M, T> supplier;

        SupplierEntry(${process.class.name} fieldId, M model, Function<M, T> supplier) {
            super();
            this.fieldId = fieldId;
            this.model = model;
            this.supplier = supplier;
        }

        @Override
        public ${process.class.name} getKey() {
            return fieldId;
        }

        @Override
        public Object getValue() {
            return supplier.apply(model);
        }

        @Override
        public Object setValue(Object value) {
            throw new UnsupportedOperationException();
        }

        @Override
        public String toString() {
            return fieldId + ", " + String.valueOf(getValue());
        }
    }
}